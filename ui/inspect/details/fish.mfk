import nes_lib

import entity/money

import ui/inspect/inspect

import ui/inspect/fish

byte inspect_fish_details_index

void init_inspect_fish_details() {
  inspect_fish_details_index = current_inspect_page * 5 + current_inspect_row
}

inline bool inspect_fish_details_tick() {
  byte temp
  render_inspect_fish_item(inspect_fish_details_index, current_inspect_row, 2)

  if (input_can_be_consumed) {
    if (input_b != 0) {
      set_inspect_screen(inspect_fish)

      // Request screen redraw
      set_screen_forcibly(inspect)
      return true
    } else if (input_select != 0 && input_start != 0) {
      // Sell fish
      // TODO: Add pricing
      refund(35)
      delete_fish(inspect_fish_details_index)

      if (inspect_packed_length == 1) {
        // Removed last fish, return to aquarium
        set_screen(aquarium)
      } else {
        // TODO: Selling the first item twice? seems to break this
        if (current_inspect_row >= current_inspect_page_length - 1 && current_inspect_page * 5 + current_inspect_page_length == inspect_packed_length) {
          // Index is now out of range
          current_inspect_row -= 1
        }

        set_inspect_screen(inspect_fish)

        // Request screen redraw
        set_screen_forcibly(inspect)
      }
    }
  }

  return false
}

void draw_inspect_fish_details_content() {
  array(byte) data [11]
  FishType type
  byte i
  byte length

  type = fish_type[inspect_fish_details_index]

  draw_fish_name(type, 7, 3, 0)

  length = sex_text.length
  for i,0,until,sex_text.length {
    data[i] = sex_text[i]
  }

  if (fish_sex[inspect_fish_details_index]) {
    for i,0,until,male_text.length {
      data[sex_text.length + i] = male_text[i]
    }
    length += male_text.length
  } else {
    for i,0,until,female_text.length {
      data[sex_text.length + i] = female_text[i]
    }
    length += female_text.length
  }

  draw_text(17, 3, data.pointer, length, 0)

  // HR
  ppu_set_addr(ppu_nametable0 + 6 * 32 + 2)
  for i,0,until,28 {
    ppu_write_data($B0)
  }

  draw_inspect_fish_data_rows()

  draw_back_button(4, 24)
  draw_start_select_button(22, 25)
}

void draw_inspect_fish_data_rows() {
  // TODO
  draw_text(5, 7, age_text.pointer, age_text.length, 0)
  draw_text_right(27, 7, not_impl_text.pointer, not_impl_text.length)

  // TODO
  draw_text(5, 9, color_text.pointer, color_text.length, 0)
  draw_text_right(27, 9, vibrant_text.pointer, vibrant_text.length)

  draw_text(5, 11, source_text.pointer, source_text.length, 0)

  if (fish_source[inspect_fish_details_index]) {
    draw_text_right(27, 11, breed_source_text.pointer, breed_source_text.length)
  } else {
    draw_text_right(27, 11, store_source_text.pointer, store_source_text.length)
  }

  // TODO
  draw_text(5, 13, status_text.pointer, status_text.length, 0)
  draw_text_right(27, 13, happy_text.pointer, happy_text.length)
}

void draw_back_button(byte x, byte y) {
  word address
  address = ppu_nametable0 + word(y) * 32 + word(x)

  ppu_set_addr(address)
  ppu_write_data($C0)
  ppu_write_data($C1)
  
  ppu_set_addr(address + 32)
  ppu_write_data($C2)
  ppu_write_data($C3)

  draw_text(x - 1, y - 1, back_text.pointer, back_text.length, 0)
}

void draw_start_select_button(byte x, byte y) {
  byte i
  word price
  array(byte) text_data [7]
  ppu_set_addr(ppu_nametable0 + word(y) * 32 + word(x))

  ppu_write_data($B1)
  ppu_write_data($B2)
  ppu_write_data($B3)
  ppu_write_data($B4)
  ppu_write_data($B5)
  ppu_write_data($B6)
  ppu_write_data($B7)

  for i,0,until,sell_text.length {
    text_data[i] = sell_text[i]
  }

  price = 35

  bcdConvert(price)

  if (bcdResult[1] != 0) {
    // Two digit number
    text_data[sell_text.length] = bcdResult[1] + $30
  } else {
    // Empty space
    text_data[sell_text.length] = $20
  }

  text_data[sell_text.length + 1] = bcdResult[0] + $30

  draw_text(x, y - 2, text_data.pointer, text_data.length, 0)
}

void draw_inspect_fish_details_attr() {
  byte i
  byte j

  // First row
  ppu_set_addr(ppu_attrtable0)
  ppu_write_data(0)
  for i,0,until,6 {
    // Top 0, bottom 2
    ppu_write_data(%10100000)
  }
  ppu_write_data(0)

  // Middle rows
  for i,0,until,5 {
    // Left 0, right 2
    ppu_write_data(%10001000)
    for j,0,until,6 {
      // All 2
      ppu_write_data(%10101010)
    }
    // Left 2, right 0
    ppu_write_data(%00100010)
  }

  // Bottom row
  ppu_write_data(0)
  for i,0,until,3 {
    // Top 2, bottom 0
    ppu_write_data(%00001010)
  }
  // Write rest 0 for start+select button
  for i,0,until,4 {
    ppu_write_data(0)
  }

  for i,0,until,8 {
    ppu_write_data(0)
  }
}

const array(byte) sex_text = [
  "Sex: " ascii
]

const array(byte) male_text = [
  "Male" ascii
]

const array(byte) female_text = [
  "Female" ascii
]

const array(byte) age_text = [
  "Age:" ascii
]

const array(byte) source_text = [
  "Source:" ascii
]

const array(byte) store_source_text = [
  "Purchased" ascii
]

const array(byte) breed_source_text = [
  "Bred" ascii
]

const array(byte) status_text = [
  "Status:" ascii
]

const array(byte) happy_text = [
  "Happy" ascii
]

const array(byte) color_text = [
  "Coloring:" ascii
]

const array(byte) vibrant_text = [
  "Vibrant" ascii
]

const array(byte) back_text = [
  "Back" ascii
]

const array(byte) sell_text = [
  "Sell " ascii
]

const array(byte) not_impl_text = [
  "Not impl" ascii
]