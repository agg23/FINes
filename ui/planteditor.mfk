import palette
import input
import bank

import ui/screen

import entity/plant
import tank/state

byte plant_editor_timer
bool active_plant_flash
PlantType plant_editor_type
byte plant_editor_x

void start_plant_editing() {
  plant_editor_timer = 0
  active_plant_flash = true
  plant_editor_type = rotala
  plant_editor_x = 0

  set_screen(plant_editor)
}

void stop_plant_editing() {
  set_screen(aquarium)
}

inline bool plant_editor_tick() {
  array(byte) data [10]

  byte temp

  if (plant_editor_timer == 0) {
    if (active_plant_flash) {
      draw_rotala(MAX_PLANT_COUNT, plant_editor_x, data.pointer)

      active_plant_flash = false
    } else {
      clear_plant_column()
    }

    plant_editor_timer = 10
  } else {
    plant_editor_timer -= 1
  }

  if (input_can_be_consumed) {  
    if (input_b != 0) {
      stop_plant_editing()
      deactivate_commandbar_selection()
      return true
    }
    if (input_a != 0) {
      add_plant(rotala, plant_editor_x, small, $FF)
      stop_plant_editing()
      deactivate_commandbar_selection()
      return true
    }
    if (input_dx < 0) {
      // Left

      if (plant_editor_x > 0) {
        clear_plant_column()
        temp = find_prev_x(plant_editor_x, rotala)

        if (temp != $FF) {
          // Found new x
          plant_editor_x = temp
        }

        plant_editor_timer = 0
        active_plant_flash = true

        return true
      }
    } else if (input_dx > 0) {
      // Right
      if (plant_editor_x < plant_max_x_bound - 1) {
        clear_plant_column()
        temp = find_next_x(plant_editor_x, rotala)

        if (temp != $FF) {
          // Found new x
          plant_editor_x = temp
        }

        plant_editor_timer = 0
        active_plant_flash = true

        return true
      }
    }
  }

  return false
}

inline byte find_next_x(byte x, PlantType type) {
  byte i
  byte count

  for i,x + 1,until,plant_max_x_bound {
    if (plant_current_x[i] == $FF) {
      // Free space. Check if plant fits
      count = available_width_at_x(i, type)

      if (count >= plant_min_width[type]) {
        // Plant fits
        return i
      }
    }
  }

  return $FF
}

byte find_prev_x(byte x, PlantType type) {
  byte i
  byte count

  for i,x - 1,downto,0 {
    if (plant_current_x[i] == $FF) {
      // Free space. Check if plant fits
      count = available_width_before_x(i, type)

      if (count >= plant_min_width[type]) {
        // Plant fits
        return i
      }
    }
  }

  return $FF
}

inline byte available_width_at_x(byte x, PlantType type) {
  byte i
  byte count
  count = 0
  for i,0,until,plant_expected_width[type] {
    if (plant_current_palettes[(i + x) >> 1] == palette_unset || plant_current_palettes[(i + x) >> 1] == plant_type_palette[type]) {
      count += 1
    } else {
      return count
    }
  }

  return count
}

inline byte available_width_before_x(byte x, PlantType type) {
  byte i
  byte count
  count = 0
  for i,0,until,plant_expected_width[type] {
    if (plant_current_palettes[(x - 1) >> 1] == palette_unset || plant_current_palettes[(x - 1) >> 1] == plant_type_palette[type]) {
      count += 1
    } else {
      return count
    }
  }

  return count
}

inline void clear_plant_column() {
  byte i
  array(byte) data [10]

  for i,0,until,10 {
    data[i] = 0
  }

  add_buffered_write(ppu_nametable0 + plant_tile_height_from_floor(10) + plant_editor_x + plant_min_x, true, data.pointer, 10)

  active_plant_flash = true
}

void draw_plant_editor() {
  load_plant_palettes()

  set_bank_0()
}

inline void load_plant_palettes() {
  add_buffered_write(ppu_palette_ram + 4, false, plant_palette.pointer, 8)
}