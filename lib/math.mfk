macro void signed_division(sbyte a, byte b, sbyte output) {
  if (a < 0) {
    output = (byte(a) / b) | $80
  } else {
    output = a / b
  }
}

macro void signed_division_const(sbyte a, byte const b, sbyte output) {
  if (a < 0) {
    // Output will also be negative
    output = 0 - ((byte(a) & $7F) / b)
  } else {
    output = a / b
  }
}

macro void signed16_division_const(signed16 a, byte const b, signed16 output) {
  if (a < 0) {
    // Output will also be negative
    output = 0 - ((word(a) & $7FFF) / b)
  } else {
    output = a / b
  }
}

macro void signed16_division(signed16 a, byte b, signed16 output) {
  if (a < 0) {
    // Output will also be negative
    output = 0 - ((word(a) & $7FFF) / b)
  } else {
    output = a / b
  }
}

macro void arithmetic_shift_right(sbyte a) {
  asm {
    lda a
    cmp #$80
    ror a
  }
}

inline void signed16_arithmetic_shift_right(signed16 a) {
  asm {
    ldy a.hi
    cpy $80
    bcc .ok
    inc a.lo
    bne .ok
    iny
    .ok:
    tya
    ror
    ror a.lo
    sta a.hi
  }
}