import graphics

struct BufferCommand {
  word address
  byte count
  byte index
  bool column
  bool pending
}

const byte MAX_WRITE_BUFFER_LENGTH = 64
const byte MAX_COMMAND_BUFFER_LENGTH = 10

array(byte) write_buffer [MAX_WRITE_BUFFER_LENGTH]
array(BufferCommand) command_buffer [MAX_COMMAND_BUFFER_LENGTH]

byte first_open_command_index
byte first_pending_command_index

byte first_open_buffer_index
byte first_data_buffer_index

void init_buffer() {
  first_open_command_index = 0
  first_pending_command_index = 0
  first_open_buffer_index = 0
  first_data_buffer_index = MAX_WRITE_BUFFER_LENGTH - 1
}

inline void process_buffered_writes() {
  // TODO: Check against V-Blank ending and stop processing commands
  byte i
  bool does_wrap
  pointer.BufferCommand command

  if (first_open_command_index < first_pending_command_index) {
    does_wrap = true
  } else {
    does_wrap = false
  }

  if (does_wrap) {
    // TODO: Fix
    asm {
      kil
    }
  } else {
    for i,first_pending_command_index,until,first_open_command_index {
      command = command_buffer[i].pointer

      if (command->pending == false) {
        // Queue completely clear. 
        init_buffer()
        return
      }

      process_command(command)
    }

    // Queue completely clear. 
    init_buffer()
  }
}

inline void process_command(pointer.BufferCommand command) {
  byte i
  byte index
  byte length_to_end
  bool does_wrap

  index = command->index

  if (command->count + index >= MAX_WRITE_BUFFER_LENGTH) {
    does_wrap = true
  } else {
    does_wrap = false
  }

  if (command->column) {
    read_ppu_status()
    ppu_ctrl = vertical_ppu_ctrl
  } else {
    read_ppu_status()
    ppu_ctrl = standard_ppu_ctrl
  }

  read_ppu_status()
  ppu_set_addr(command->address)

  if (does_wrap) {
    length_to_end = MAX_WRITE_BUFFER_LENGTH - command->index
    for i,0,until,length_to_end {
      ppu_write_data(write_buffer[index + i])
    }

    // length_after_start
    length_to_end = command->count - length_to_end
    for i,0,until,length_to_end {
      ppu_write_data(write_buffer[i])
    }

    first_data_buffer_index = length_to_end
  } else {
    for i,0,until,command->count {
      ppu_write_data(write_buffer[index + i])
    }

    first_data_buffer_index += command->count
  }

  command->pending = false
  first_pending_command_index += 1
}

inline void add_buffered_write(word address, bool write_column, pointer.byte data, byte length) {
  byte i
  byte temp
  byte length_to_end
  bool does_wrap
  byte index

  temp = MAX_WRITE_BUFFER_LENGTH - first_open_buffer_index
  if (temp < length) {
    // Space until end + index of first data after wrap
    temp = temp + first_data_buffer_index
    does_wrap = true
  } else {
    temp = MAX_WRITE_BUFFER_LENGTH - first_open_buffer_index
    does_wrap = false
  }

  // If free space < length
  if (temp < length) {
    // Out of buffer space
    asm {
      kil
    }

    return
  }

  index = first_open_buffer_index

  if (does_wrap) {
    length_to_end = MAX_WRITE_BUFFER_LENGTH - first_open_buffer_index
    // length_after_start
    temp = length - length_to_end
    // Up to end of buffer
    for i,0,until,length_to_end {
      write_buffer[first_open_buffer_index + i] = data[i]
    }

    for i,0,until,temp {
      write_buffer[i] = data[length_to_end + i]
    }

    first_open_buffer_index = temp
  } else {
    for i,0,until,length {
      write_buffer[first_open_buffer_index + i] = data[i]
    }

    first_open_buffer_index = first_open_buffer_index + length
  }

  pointer.BufferCommand command
  command = command_buffer[first_open_command_index].pointer
  command->address = address
  command->count = length
  command->index = index
  command->column = write_column
  command->pending = true

  if (first_open_command_index == MAX_COMMAND_BUFFER_LENGTH - 1) {
    first_open_command_index = 0
  } else {
    first_open_command_index += 1
  }
}
