import random
import custom_random
import movement_lib

import tank/state
import entity/health

enum FishType {
  small,
  cherry_shrimp
}


const byte MAX_FISH_COUNT = 20

array(byte) fish_x [MAX_FISH_COUNT]
array(byte) fish_y [MAX_FISH_COUNT]
array(word) fish_velocity_x [MAX_FISH_COUNT]
array(word) fish_velocity_y [MAX_FISH_COUNT]
array(FishType) fish_type [MAX_FISH_COUNT]
array(bool) fish_sex [MAX_FISH_COUNT]

byte active_fish_count = 0

byte male_small_fish_count
byte female_small_fish_count

const word FISH_MAX_VELOCITY_PER_TICK = $100
const word FISH_MAX_VERTICAL_VELOCITY_PER_TICK = $100
const byte FISH_MAX_VELOCITY = 2
const byte FISH_DECAY_VELOCITY_PER_TICK = $20

void init_fish() {
  spawn_fish(small, true)
  spawn_fish(cherry_shrimp, true)
  spawn_fish(small, false)
}

void spawn_fish(FishType type, bool sex) {
  if (active_fish_count >= MAX_FISH_COUNT) {
    return
  }

  fish_x[active_fish_count] = $80
  fish_y[active_fish_count] = $20
  fish_velocity_x[active_fish_count] = $250
  fish_velocity_y[active_fish_count] = $1000
  fish_type[active_fish_count] = type
  fish_sex[active_fish_count] = sex

  if (sex) {
    male_small_fish_count += 1
  } else {
    female_small_fish_count += 1
  }

  active_fish_count += 1
}

void fish_tick() {
  fish_move()
  fish_breed()
}

inline void fish_move() {
  byte i
  byte random_direction
  byte x
  byte y
  word velocity_x
  word velocity_y

  for i,0,until,active_fish_count {

    x = fish_x[i]
    y = fish_y[i]
    velocity_x = fish_velocity_x[i]
    velocity_y = fish_velocity_y[i]

    if (rand() < 20) {
      random_direction = rand()

      if random_direction < $20 {
        // Low chance to move vertically
        if random_direction < $10 {
          // Up
          velocity_y -= FISH_MAX_VERTICAL_VELOCITY_PER_TICK
        } else {
          // Down
          velocity_y += FISH_MAX_VERTICAL_VELOCITY_PER_TICK
        }
      } else {
        if random_direction < $79 {
          // Left
          velocity_x -= FISH_MAX_VELOCITY_PER_TICK
        } else {
          // Right
          velocity_x += FISH_MAX_VELOCITY_PER_TICK
        }
      }

      cap_velocity(velocity_x.hi, velocity_x.lo, FISH_MAX_VELOCITY)
      cap_velocity(velocity_y.hi, velocity_y.lo, FISH_MAX_VELOCITY)
    }

    x += sbyte(velocity_x.hi)
    y += sbyte(velocity_y.hi)

    cap_fish_location_to_active_tank(x, y)

    fish_x[i] = x
    fish_y[i] = y

    // decay_velocity(velocity_x.hi, velocity_x.lo, FISH_DECAY_VELOCITY_PER_TICK)
    // decay_velocity(velocity_y.hi, velocity_y.lo, FISH_DECAY_VELOCITY_PER_TICK)

    fish_velocity_x[i] = velocity_x
    fish_velocity_y[i] = velocity_y
  }
}

inline void cherry_shrimp_move(byte i) {

}

inline void fish_breed() {
  byte temp
  if (male_small_fish_count < 1 || female_small_fish_count < 1) {
    // Breeding cannot occur
    return
  }

  random_int_const(0, MAX_FISH_COUNT, temp)

  if (temp < (male_small_fish_count + female_small_fish_count) / 2 && rand() < 1) {
    // Breed
    random_int_const(0, 1, temp)
    spawn_fish(small, temp == 1)
  }
}

inline void fish_breathe() {
  // TODO: Base on fish size
  byte i

  for i,0,until,active_fish_count {
    if (rand() < $40) {
      increase_ammonia(1)
    }
  }
}

inline void render_fish() {
  byte i
  byte direction_mask
  for i,0,until,active_fish_count {
    if (sbyte(fish_velocity_x[i].hi) >= 0) {
      direction_mask = 0
    } else {
      direction_mask = %01000000
    }

    oam_buffer[oam_index] = fish_y[i]
    oam_buffer[oam_index + 1] = $80 + byte(fish_type[i])
    oam_buffer[oam_index + 2] = direction_mask
    oam_buffer[oam_index + 3] = fish_x[i]

    oam_index += 4
  }
}