import random
import custom_random
import movement_lib

import tank/state
import entity/health

enum FishType {
  small,
  cherry_shrimp
}

struct Fish {
  byte x,
  byte y,
  word velocity_x,
  word velocity_y,
  FishType type
  bool sex
}

const byte FISH_MAX_COUNT = 20

array(Fish) fish_instances [FISH_MAX_COUNT]
byte active_fish_count = 0

byte male_small_fish_count
byte female_small_fish_count

const word FISH_MAX_VELOCITY_PER_TICK = $100
const word FISH_MAX_VERTICAL_VELOCITY_PER_TICK = $100
const byte FISH_MAX_VELOCITY = 2
const byte FISH_DECAY_VELOCITY_PER_TICK = $20

void init_fish() {
  spawn_fish(small, true)
  spawn_fish(cherry_shrimp, true)
  spawn_fish(small, false)
}

void spawn_fish(FishType type, bool sex) {
  if (active_fish_count >= FISH_MAX_COUNT) {
    return
  }

  Fish fish
  fish.x = $80
  fish.y = $20
  fish.type = type
  fish.sex = sex

  fish_instances[active_fish_count] = fish

  if (sex) {
    male_small_fish_count += 1
  } else {
    female_small_fish_count += 1
  }

  active_fish_count += 1
}

void fish_tick() {
  fish_move()
  fish_breed()
}

inline void fish_move() {
  byte i
  byte random_direction
  byte x
  byte y
  word velocity_x
  word velocity_y
  pointer.Fish fish

  for i,0,until,active_fish_count {
    fish = fish_instances[i].pointer

    x = fish->x
    y = fish->y
    velocity_x = fish->velocity_x
    velocity_y = fish->velocity_y

    if (rand() < 20) {
      random_direction = rand()

      if random_direction < $20 {
        // Low chance to move vertically
        if random_direction < $10 {
          // Up
          velocity_y -= FISH_MAX_VERTICAL_VELOCITY_PER_TICK
        } else {
          // Down
          velocity_y += FISH_MAX_VERTICAL_VELOCITY_PER_TICK
        }
      } else {
        if random_direction < $79 {
          // Left
          velocity_x -= FISH_MAX_VELOCITY_PER_TICK
        } else {
          // Right
          velocity_x += FISH_MAX_VELOCITY_PER_TICK
        }
      }

      cap_velocity(velocity_x.hi, velocity_x.lo, FISH_MAX_VELOCITY)
      cap_velocity(velocity_y.hi, velocity_y.lo, FISH_MAX_VELOCITY)
    }

    x += sbyte(velocity_x.hi)
    y += sbyte(velocity_y.hi)

    cap_fish_location_to_active_tank(x, y)

    fish->x = x
    fish->y = y

    // decay_velocity(velocity_x.hi, velocity_x.lo, FISH_DECAY_VELOCITY_PER_TICK)
    // decay_velocity(velocity_y.hi, velocity_y.lo, FISH_DECAY_VELOCITY_PER_TICK)

    fish->velocity_x = velocity_x
    fish->velocity_y = velocity_y
  }
}

inline void fish_breed() {
  byte temp
  if (male_small_fish_count < 1 || female_small_fish_count < 1) {
    // Breeding cannot occur
    return
  }

  random_int_const(0, FISH_MAX_COUNT, temp)

  if (temp < (male_small_fish_count + female_small_fish_count) / 2 && rand() < 1) {
    // Breed
    random_int_const(0, 1, temp)
    spawn_fish(small, temp == 1)
  }
}

inline void fish_breathe() {
  // TODO: Base on fish size
  byte i

  for i,0,until,active_fish_count {
    if (rand() < $40) {
      increase_ammonia(1)
    }
  }
}

inline void render_fish() {
  byte i
  byte direction_mask
  Fish fish
  for i,0,until,active_fish_count {
    fish = fish_instances[i]

    if (sbyte(fish.velocity_x.hi) >= 0) {
      direction_mask = 0
    } else {
      direction_mask = %01000000
    }

    oam_buffer[oam_index] = fish.y
    oam_buffer[oam_index + 1] = $80 + byte(fish.type)
    oam_buffer[oam_index + 2] = direction_mask
    oam_buffer[oam_index + 3] = fish.x

    oam_index += 4
  }
}