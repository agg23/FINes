import random
import custom_random
import movement_lib
import math

import tank/state
import entity/health

enum FishType {
  tetra,
  rasbora,
  cherry_shrimp
}


const byte MAX_FISH_COUNT = 20

array(byte) fish_x [MAX_FISH_COUNT]
array(byte) fish_y [MAX_FISH_COUNT]
array(sbyte) fish_velocity_x [MAX_FISH_COUNT]
array(sbyte) fish_velocity_y [MAX_FISH_COUNT]
array(FishType) fish_type [MAX_FISH_COUNT]
array(bool) fish_sex [MAX_FISH_COUNT]
array(bool) fish_alive [MAX_FISH_COUNT]

byte active_fish_count = 0

byte male_small_fish_count
byte female_small_fish_count

const word FISH_MAX_VELOCITY_PER_TICK = 6
const byte FISH_MAX_VELOCITY = 5
const byte FISH_DECAY_VELOCITY_PER_TICK = $20

void init_fish() {
  spawn_fish(tetra, true, $80, $20)
  spawn_fish(rasbora, true, $60, $84)
  // spawn_fish(cherry_shrimp, true)
  spawn_fish(tetra, false, $70, $A0)
}

void spawn_fish(FishType type, bool sex, byte x, byte y) {
  if (active_fish_count >= MAX_FISH_COUNT) {
    return
  }

  byte i
  for i,0,until,MAX_FISH_COUNT {
    if (not(fish_alive[i])) {
      // Spawn fish
      fish_x[i] = x
      fish_y[i] = y
      fish_velocity_x[i] = 0
      fish_velocity_y[i] = 0
      fish_type[i] = type
      fish_sex[i] = sex
      fish_alive[i] = true

      if (sex) {
        male_small_fish_count += 1
      } else {
        female_small_fish_count += 1
      }

      active_fish_count += 1

      return
    }
  }
}

void fish_tick() {
  fish_move()
  fish_breed()
}

inline void fish_move() {
  byte i
  byte random_direction
  byte x
  byte y
  word velocity_x
  word velocity_y
  bool did_change

  for i,0,until,MAX_FISH_COUNT {
    if (not(fish_alive[i])) {
      continue
    }

    if (fish_type[i] == tetra || fish_type[i] == rasbora) {
      tetra_fish_move(i)
    } else if (fish_type[i] == cherry_shrimp) {
      // cherry_shrimp_move(i)
    }
  }
}

inline void tetra_fish_move(byte i) {
  sbyte x_velocity
  sbyte y_velocity
  word temp

  temp = boid_center_mass_step(i)
  x_velocity = sbyte(temp.hi)
  y_velocity = sbyte(temp.lo)

  temp = boid_distance_step(i)
  x_velocity += sbyte(temp.hi)
  y_velocity += sbyte(temp.lo)

  // temp = boid_average_velocity_step(i)
  // x_velocity += sbyte(temp.hi)
  // y_velocity += sbyte(temp.lo)

  // fish_velocity_x[i] += x_velocity
  // fish_velocity_y[i] += y_velocity

  x_velocity = sbyte(x_velocity) + fish_velocity_x[i]
  y_velocity = sbyte(y_velocity) + fish_velocity_y[i]

  if (sbyte(x_velocity) < -FISH_MAX_VELOCITY) {
    x_velocity = -FISH_MAX_VELOCITY
  } else if (x_velocity > FISH_MAX_VELOCITY) {
    x_velocity = FISH_MAX_VELOCITY
  }

  if (sbyte(y_velocity) < -FISH_MAX_VELOCITY) {
    y_velocity = -FISH_MAX_VELOCITY
  } else if (y_velocity > FISH_MAX_VELOCITY) {
    y_velocity = FISH_MAX_VELOCITY
  }

  // if (sbyte(y_velocity) < 0) {
  //   y_velocity = -1
  // } else if (y_velocity > 0) {
  //   y_velocity = 1
  // }

  // signed_division_const(x_velocity, 8, x_velocity)
  // signed_division_const(y_velocity, 8, y_velocity)

  byte x
  byte y
  bool did_change

  x = fish_x[i] + x_velocity
  y = fish_y[i] + y_velocity

  cap_fish_location_to_active_tank(x, y, did_change)

  fish_x[i] = x
  fish_y[i] = y

  // if (sbyte(x_velocity) < 0) {
  //   fish_velocity_x[i] = x_velocity + 1
  // } else if (x_velocity > 0) {
  //   fish_velocity_x[i] = x_velocity - 1
  // }

  // if (sbyte(y_velocity) < 0) {
  //   fish_velocity_y[i] = y_velocity + 1
  // } else if (y_velocity > 0) {
  //   fish_velocity_y[i] = y_velocity - 1
  // }

  if (did_change) {
    fish_velocity_x[i] = fish_velocity_x[i] * -1
    fish_velocity_y[i] = fish_velocity_y[i] * -1
  }
}

inline word boid_center_mass_step(byte i) {
  word center
  center = perceived_boid_center(i)

  word output
  signed16 stemp
  signed16 temp_out

  stemp = signed16(center.hi) - signed16(fish_x[i])
  // signed16_division_const(stemp, 64, temp_out)
  output.hi = stemp.hi

  stemp = signed16(center.lo) - signed16(fish_y[i])
  // signed16_division_const(stemp, 64, temp_out)
  output.lo = stemp.lo

  return output
}

inline word boid_distance_step(byte i) {
  byte j
  word temp
  sbyte displacement_x
  sbyte displacement_y
  signed16 x_distance
  signed16 y_distance

  displacement_x = 0
  displacement_y = 0

  for j,0,until,MAX_FISH_COUNT {
    if (i != j && fish_alive[j]) {
      // Naive fast distance
      x_distance = signed16(fish_x[j]) - signed16(fish_x[i])
      y_distance = signed16(fish_y[j]) - signed16(fish_y[i])

      temp = word(x_distance.lo * x_distance.lo) + word(y_distance.lo * y_distance.lo)

      if (temp < 30) {
        displacement_x -= sbyte(x_distance.lo)
        displacement_y -= sbyte(y_distance.lo)
      }
    }
  }

  word output
  output.hi = displacement_x
  output.lo = displacement_y
  return output
}

inline word boid_average_velocity_step(byte i) {
  byte j
  word sum_x
  word sum_y
  byte count

  for j,0,until,MAX_FISH_COUNT {
    if (i != j && fish_alive[j]) {
      sum_x += fish_velocity_x[j]
      sum_y += fish_velocity_y[j]
      count += 1
    }
  }

  sum_x = sum_x / count
  sum_y = sum_y / count

  word output
  output.hi = (sum_x.lo - fish_velocity_x[i]) >> 3
  output.lo = (sum_y.lo - fish_velocity_y[i]) >> 3

  return output
}

inline word perceived_boid_center(byte i) {
  byte j
  word sum_x
  word sum_y
  byte count

  sum_x = 0
  sum_y = 0
  count = 0

  for j,0,until,MAX_FISH_COUNT {
    if (j != i && fish_alive[j]) {
      sum_x += fish_x[j]
      sum_y += fish_y[j]
      count += 1
    }
  }

  sum_x = sum_x / count
  sum_y = sum_y / count

  word output
  output.hi = sum_x.lo
  output.lo = sum_y.lo

  return output
}

// inline void cherry_shrimp_move(byte i) {
//   byte x
//   byte y
//   word velocity_x
//   word velocity_y
//   bool did_change

//   did_change = false

//   x = fish_x[i]
//   y = fish_y[i]
//   velocity_x = fish_velocity_x[i]
//   velocity_y = fish_velocity_y[i]

//   if (rand() < 8) {
//     // Small chance to swim upwards
//     velocity_y -= $400
//   }

//   if (velocity_y.hi > $7f) {
//     velocity_y += $80
//   }

//   x += sbyte(velocity_x.hi)
//   y += sbyte(velocity_y.hi)

//   cap_fish_location_to_active_tank(x, y, did_change)

//   fish_x[i] = x
//   fish_y[i] = y

//   fish_velocity_x[i] = velocity_x
//   fish_velocity_y[i] = velocity_y
// }

inline void fish_breed() {
  byte temp
  if (male_small_fish_count < 1 || female_small_fish_count < 1) {
    // Breeding cannot occur
    return
  }

  random_int_const(0, MAX_FISH_COUNT, temp)

  if (temp < (male_small_fish_count + female_small_fish_count) / 2 && rand() < 1) {
    // Breed
    random_int_const(0, 1, temp)
    spawn_fish(tetra, temp == 1, $80, $20)
  }
}

inline void fish_breathe() {
  // TODO: Base on fish size
  byte i

  for i,0,until,MAX_FISH_COUNT {
    if (fish_alive[i] && rand() < $40) {
      increase_ammonia(1)
    }
  }
}

inline void render_fish() {
  byte i
  byte mask
  bool pos_direction
  for i,0,until,MAX_FISH_COUNT {
    if (not(fish_alive[i])) {
      continue
    }

    pos_direction = sbyte(fish_velocity_x[i]) >= 0
    if (pos_direction) {
      mask = 0
    } else {
      mask = %01000000
    }

    if (fish_type[i] == tetra) {
      render_two_tile_fish(i, mask, pos_direction, 1, tetra_tiles.pointer)
    } else if (fish_type[i] == rasbora) {
      render_two_tile_fish(i, mask, pos_direction, 2, rasbora_tiles.pointer)
    } else {
      oam_buffer[oam_index] = fish_y[i]
      oam_buffer[oam_index + 1] = $81
      oam_buffer[oam_index + 2] = mask
      oam_buffer[oam_index + 3] = fish_x[i]

      oam_index += 4
    }
  }
}

macro void render_two_tile_fish(byte i, byte mask, bool pos_direction, byte const palette, pointer.byte const data) {
  oam_buffer[oam_index] = fish_y[i]
  if (pos_direction) {
    oam_buffer[oam_index + 1] = data[0]
  } else {
    oam_buffer[oam_index + 1] = data[1]
  }
  // Palette 1
  oam_buffer[oam_index + 2] = mask | palette
  oam_buffer[oam_index + 3] = fish_x[i] - 8

  oam_index += 4

  oam_buffer[oam_index] = fish_y[i]
  if (pos_direction) {
    oam_buffer[oam_index + 1] = data[1]
  } else {
    oam_buffer[oam_index + 1] = data[0]
  }
  // Palette 1
  oam_buffer[oam_index + 2] = mask | palette
  oam_buffer[oam_index + 3] = fish_x[i]

  oam_index += 4
}

const array(byte) tetra_tiles = [$82, $83]
const array(byte) rasbora_tiles = [$84, $85]