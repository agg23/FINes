import random
import custom_random
import movement_lib
import math

import tank/state
import entity/health

enum FishType {
  tetra,
  rasbora,
  cherry_shrimp
}


const byte MAX_FISH_COUNT = 20

array(byte) fish_x [MAX_FISH_COUNT]
array(byte) fish_y [MAX_FISH_COUNT]
array(signed16) fish_velocity_x [MAX_FISH_COUNT]
array(signed16) fish_velocity_y [MAX_FISH_COUNT]
array(FishType) fish_type [MAX_FISH_COUNT]
array(bool) fish_sex [MAX_FISH_COUNT]
array(bool) fish_alive [MAX_FISH_COUNT]

byte active_fish_count = 0

byte male_small_fish_count
byte female_small_fish_count

const word FISH_MAX_VELOCITY_PER_TICK = 6
const word FISH_MAX_VELOCITY = $200
const byte FISH_DECAY_VELOCITY_PER_TICK = $20

signed16 fish_diff_velocity_x
signed16 fish_diff_velocity_y

void init_fish() {
  spawn_fish(tetra, true, $80, $26)
  spawn_fish(rasbora, true, $60, $84)
  // spawn_fish(cherry_shrimp, true)
  spawn_fish(tetra, false, $34, $B2)
}

void spawn_fish(FishType type, bool sex, byte x, byte y) {
  if (active_fish_count >= MAX_FISH_COUNT) {
    return
  }

  byte i
  for i,0,until,MAX_FISH_COUNT {
    if (not(fish_alive[i])) {
      // Spawn fish
      fish_x[i] = x
      fish_y[i] = y
      fish_velocity_x[i] = 0
      fish_velocity_y[i] = 0
      fish_type[i] = type
      fish_sex[i] = sex
      fish_alive[i] = true

      if (sex) {
        male_small_fish_count += 1
      } else {
        female_small_fish_count += 1
      }

      active_fish_count += 1

      return
    }
  }
}

void fish_tick() {
  fish_move()
  fish_breed()
}

inline void fish_move() {
  byte i
  byte random_direction
  byte x
  byte y
  word velocity_x
  word velocity_y
  bool did_change

  for i,0,until,MAX_FISH_COUNT {
    if (not(fish_alive[i])) {
      continue
    }

    if (fish_type[i] == tetra || fish_type[i] == rasbora) {
      tetra_fish_move(i)
    } else if (fish_type[i] == cherry_shrimp) {
      // cherry_shrimp_move(i)
    }
  }
}

inline void tetra_fish_move(byte i) {
  fish_diff_velocity_x = fish_velocity_x[i]
  fish_diff_velocity_y = fish_velocity_y[i]

  boid_center_mass_step(i)

  boid_distance_step(i)

  // boid_average_velocity_step(i)

  bound_position(i)

  if (fish_diff_velocity_x < -FISH_MAX_VELOCITY) {
    fish_diff_velocity_x = -FISH_MAX_VELOCITY
  } else if (fish_diff_velocity_x > FISH_MAX_VELOCITY) {
    fish_diff_velocity_x = FISH_MAX_VELOCITY
  }

  if (fish_diff_velocity_y < -FISH_MAX_VELOCITY) {
    fish_diff_velocity_y = -FISH_MAX_VELOCITY
  } else if (fish_diff_velocity_y > FISH_MAX_VELOCITY) {
    fish_diff_velocity_y = FISH_MAX_VELOCITY
  }

  fish_velocity_x[i] = fish_diff_velocity_x
  fish_velocity_y[i] = fish_diff_velocity_y

  sbyte applied_x_velocity
  sbyte applied_y_velocity

  applied_x_velocity = fish_diff_velocity_x.hi
  applied_y_velocity = fish_diff_velocity_y.hi

  // arithmetic_shift_right(applied_x_velocity)
  // arithmetic_shift_right(applied_y_velocity)
  // arithmetic_shift_right(x_velocity)
  // arithmetic_shift_right(x_velocity)
  // arithmetic_shift_right(y_velocity)
  // arithmetic_shift_right(y_velocity)
  // arithmetic_shift_right(y_velocity)
  // arithmetic_shift_right(y_velocity)

  // fish_velocity_x[i] += x_velocity
  // fish_velocity_y[i] += y_velocity

  // x_velocity = sbyte(x_velocity) + fish_velocity_x[i]
  // y_velocity = sbyte(y_velocity) + fish_velocity_y[i]

  // if (sbyte(y_velocity) < 0) {
  //   y_velocity = -1
  // } else if (y_velocity > 0) {
  //   y_velocity = 1
  // }

  // signed_division_const(x_velocity, 8, x_velocity)
  // signed_division_const(y_velocity, 8, y_velocity)

  byte x
  byte y
  bool did_change

  x = fish_x[i] + applied_x_velocity
  y = fish_y[i] + applied_y_velocity

  cap_fish_location_to_active_tank(x, y, did_change)

  fish_x[i] = x
  fish_y[i] = y
}

inline void boid_center_mass_step(byte i) {
  word center
  center = perceived_boid_center(i)

  word output
  signed16 stemp
  word temp_out

  stemp = signed16(center.hi) - signed16(fish_x[i])
  // Want to divide by 128 (shift right 7 times)
  // Since we're using two ints here, not fractional words, we shift (data << 8) >> 7 = data << 1
  // fish_diff_velocity_x += stemp << 1
  // TODO: Removed shift left
  signed16_arithmetic_shift_right(stemp)
  fish_diff_velocity_x += stemp
  // signed16_arithmetic_shift_right(stemp)
  // signed16_arithmetic_shift_right(stemp)
  // signed16_arithmetic_shift_right(stemp)
  // signed16_division_const(stemp, 16, temp_out)
  // output.hi = stemp.lo

  stemp = signed16(center.lo) - signed16(fish_y[i])
  signed16_arithmetic_shift_right(stemp)
  fish_diff_velocity_y += stemp
  // fish_diff_velocity_y += stemp << 1
  // signed16_arithmetic_shift_right(stemp)
  // signed16_arithmetic_shift_right(stemp)
  // signed16_arithmetic_shift_right(stemp)
  // signed16_division_const(stemp, 16, temp_out)
  // output.lo = stemp.lo
}

inline void boid_distance_step(byte i) {
  byte j
  word temp
  signed16 displacement_x
  signed16 displacement_y
  signed16 x_distance
  signed16 y_distance

  displacement_x = 0
  displacement_y = 0

  for j,0,until,MAX_FISH_COUNT {
    if (i != j && fish_alive[j]) {
      // Naive fast distance
      x_distance = signed16(fish_x[j]) - signed16(fish_x[i])
      y_distance = signed16(fish_y[j]) - signed16(fish_y[i])

      // This may not work due to these values being signed
      temp = word(x_distance * x_distance) + word(y_distance * y_distance)

      if (temp < 100) {
        // signed16_arithmetic_shift_right(x_distance)
        displacement_x -= x_distance
        // signed16_arithmetic_shift_right(y_distance)
        displacement_y -= y_distance
      }
    }
  }

  // signed16_arithmetic_shift_right(displacement_x)
  // arithmetic_shift_right(displacement_x)
  // signed16_arithmetic_shift_right(displacement_y)
  // arithmetic_shift_right(displacement_y)

  fish_diff_velocity_x += displacement_x
  fish_diff_velocity_y += displacement_y

  // word output
  // output.hi = displacement_x
  // output.lo = displacement_y
  // return output
}

inline void boid_average_velocity_step(byte i) {
  byte j
  signed16 sum_x
  signed16 sum_y
  byte count

  for j,0,until,MAX_FISH_COUNT {
    if (i != j && fish_alive[j]) {
      sum_x += fish_velocity_x[j]
      sum_y += fish_velocity_y[j]
      count += 1
    }
  }

  signed16_division(sum_x, count, sum_x)
  signed16_division(sum_y, count, sum_y)

  signed16 temp
  temp = sum_x - fish_velocity_x[i]
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)

  fish_diff_velocity_x += temp.hi

  temp = sum_y - fish_velocity_y[i]
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)
  // signed16_arithmetic_shift_right(temp)

  fish_diff_velocity_y += temp.lo
}

inline word perceived_boid_center(byte i) {
  byte j
  word sum_x
  word sum_y
  byte count

  sum_x = 0
  sum_y = 0
  count = 0

  for j,0,until,MAX_FISH_COUNT {
    if (fish_alive[j]) {
      sum_x += fish_x[j]
      sum_y += fish_y[j]
      count += 1
    }
  }

  sum_x = sum_x / count
  sum_y = sum_y / count

  word output
  // Output must fit in single byte, as avg of x will always be < 256
  output.hi = sum_x.lo
  output.lo = sum_y.lo

  oam_buffer[oam_index] = sum_y.lo
  oam_buffer[oam_index + 1] = $1
  oam_buffer[oam_index + 2] = 0
  oam_buffer[oam_index + 3] = sum_x.lo

  oam_index += 4

  return output
}

inline void bound_position(byte i) {
  if (fish_x[i] < active_tank.x_low + 16) {
    fish_diff_velocity_x += $40
  } else if (fish_x[i] > active_tank.x_high - 16) {
    fish_diff_velocity_x -= $40
  }

  if (fish_y[i] < active_tank.y_low + 16) {
    fish_diff_velocity_y += $40
  } else if (fish_y[i] > active_tank.y_high - 16) {
    fish_diff_velocity_y -= $40
  }
}

// inline void cherry_shrimp_move(byte i) {
//   byte x
//   byte y
//   word velocity_x
//   word velocity_y
//   bool did_change

//   did_change = false

//   x = fish_x[i]
//   y = fish_y[i]
//   velocity_x = fish_velocity_x[i]
//   velocity_y = fish_velocity_y[i]

//   if (rand() < 8) {
//     // Small chance to swim upwards
//     velocity_y -= $400
//   }

//   if (velocity_y.hi > $7f) {
//     velocity_y += $80
//   }

//   x += sbyte(velocity_x.hi)
//   y += sbyte(velocity_y.hi)

//   cap_fish_location_to_active_tank(x, y, did_change)

//   fish_x[i] = x
//   fish_y[i] = y

//   fish_velocity_x[i] = velocity_x
//   fish_velocity_y[i] = velocity_y
// }

inline void fish_breed() {
  byte temp
  if (male_small_fish_count < 1 || female_small_fish_count < 1) {
    // Breeding cannot occur
    return
  }

  random_int_const(0, MAX_FISH_COUNT, temp)

  if (temp < (male_small_fish_count + female_small_fish_count) / 2 && rand() < 1) {
    // Breed
    random_int_const(0, 1, temp)
    spawn_fish(tetra, temp == 1, $80, $20)
  }
}

inline void fish_breathe() {
  // TODO: Base on fish size
  byte i

  for i,0,until,MAX_FISH_COUNT {
    if (fish_alive[i] && rand() < $40) {
      increase_ammonia(1)
    }
  }
}

inline void render_fish() {
  byte i
  byte mask
  bool pos_direction
  for i,0,until,MAX_FISH_COUNT {
    if (not(fish_alive[i])) {
      continue
    }

    pos_direction = fish_velocity_x[i].hi & $80 == 0
    if (pos_direction) {
      mask = 0
    } else {
      mask = %01000000
    }

    if (fish_type[i] == tetra) {
      render_two_tile_fish(i, mask, pos_direction, 1, tetra_tiles.pointer)
    } else if (fish_type[i] == rasbora) {
      render_two_tile_fish(i, mask, pos_direction, 2, rasbora_tiles.pointer)
    } else {
      oam_buffer[oam_index] = fish_y[i]
      oam_buffer[oam_index + 1] = $81
      oam_buffer[oam_index + 2] = mask
      oam_buffer[oam_index + 3] = fish_x[i]

      oam_index += 4
    }
  }
}

macro void render_two_tile_fish(byte i, byte mask, bool pos_direction, byte const palette, pointer.byte const data) {
  oam_buffer[oam_index] = fish_y[i]
  if (pos_direction) {
    oam_buffer[oam_index + 1] = data[0]
  } else {
    oam_buffer[oam_index + 1] = data[1]
  }
  // Palette 1
  oam_buffer[oam_index + 2] = mask | palette
  oam_buffer[oam_index + 3] = fish_x[i] - 8

  oam_index += 4

  oam_buffer[oam_index] = fish_y[i]
  if (pos_direction) {
    oam_buffer[oam_index + 1] = data[1]
  } else {
    oam_buffer[oam_index + 1] = data[0]
  }
  // Palette 1
  oam_buffer[oam_index + 2] = mask | palette
  oam_buffer[oam_index + 3] = fish_x[i]

  oam_index += 4
}

const array(byte) tetra_tiles = [$82, $83]
const array(byte) rasbora_tiles = [$84, $85]