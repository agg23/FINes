import random
import custom_random
import movement_lib

import tank/state
import entity/health

enum FishType {
  tetra,
  rasbora,
  cherry_shrimp
}


const byte MAX_FISH_COUNT = 20

array(byte) fish_x [MAX_FISH_COUNT]
array(byte) fish_y [MAX_FISH_COUNT]
array(word) fish_velocity_x [MAX_FISH_COUNT]
array(word) fish_velocity_y [MAX_FISH_COUNT]
array(FishType) fish_type [MAX_FISH_COUNT]
array(bool) fish_sex [MAX_FISH_COUNT]

byte active_fish_count = 0

byte male_small_fish_count
byte female_small_fish_count

const word FISH_MAX_VELOCITY_PER_TICK = $100
const word FISH_MAX_VERTICAL_VELOCITY_PER_TICK = $100
const byte FISH_MAX_VELOCITY = 2
const byte FISH_DECAY_VELOCITY_PER_TICK = $20

void init_fish() {
  spawn_fish(tetra, true)
  spawn_fish(rasbora, true)
  spawn_fish(cherry_shrimp, true)
  spawn_fish(tetra, false)
}

void spawn_fish(FishType type, bool sex) {
  if (active_fish_count >= MAX_FISH_COUNT) {
    return
  }

  fish_x[active_fish_count] = $80
  fish_y[active_fish_count] = $20
  fish_velocity_x[active_fish_count] = $250
  fish_velocity_y[active_fish_count] = $500
  fish_type[active_fish_count] = type
  fish_sex[active_fish_count] = sex

  if (sex) {
    male_small_fish_count += 1
  } else {
    female_small_fish_count += 1
  }

  active_fish_count += 1
}

void fish_tick() {
  fish_move()
  fish_breed()
}

inline void fish_move() {
  byte i
  byte random_direction
  byte x
  byte y
  word velocity_x
  word velocity_y
  bool did_change

  for i,0,until,active_fish_count {
    if (fish_type[i] == tetra || fish_type[i] == rasbora) {
      tetra_fish_move(i)
    } else if (fish_type[i] == cherry_shrimp) {
      cherry_shrimp_move(i)
    }
  }
}

inline void tetra_fish_move(byte i) {
  byte random_direction
  byte x
  byte y
  word velocity_x
  word velocity_y
  bool did_change

  did_change = false

  x = fish_x[i]
  y = fish_y[i]
  velocity_x = fish_velocity_x[i]
  velocity_y = fish_velocity_y[i]

  if (rand() < 20) {
    random_direction = rand()

    if random_direction < $20 {
      // Low chance to move vertically
      if random_direction < $10 {
        // Up
        velocity_y -= FISH_MAX_VERTICAL_VELOCITY_PER_TICK
      } else {
        // Down
        velocity_y += FISH_MAX_VERTICAL_VELOCITY_PER_TICK
      }
    } else {
      if random_direction < $79 {
        // Left
        velocity_x -= FISH_MAX_VELOCITY_PER_TICK
      } else {
        // Right
        velocity_x += FISH_MAX_VELOCITY_PER_TICK
      }
    }

    cap_velocity(velocity_x.hi, velocity_x.lo, FISH_MAX_VELOCITY)
    cap_velocity(velocity_y.hi, velocity_y.lo, FISH_MAX_VELOCITY)
  }

  x += sbyte(velocity_x.hi)
  y += sbyte(velocity_y.hi)

  cap_fish_location_to_active_tank(x, y, did_change)

  if (did_change) {
    velocity_x = 0
    velocity_y = 0
  }

  fish_x[i] = x
  fish_y[i] = y

  // decay_velocity(velocity_x.hi, velocity_x.lo, FISH_DECAY_VELOCITY_PER_TICK)
  // decay_velocity(velocity_y.hi, velocity_y.lo, FISH_DECAY_VELOCITY_PER_TICK)

  fish_velocity_x[i] = velocity_x
  fish_velocity_y[i] = velocity_y
}

inline void cherry_shrimp_move(byte i) {
  byte x
  byte y
  word velocity_x
  word velocity_y
  bool did_change

  did_change = false

  x = fish_x[i]
  y = fish_y[i]
  velocity_x = fish_velocity_x[i]
  velocity_y = fish_velocity_y[i]

  if (rand() < 8) {
    // Small chance to swim upwards
    velocity_y -= $400
  }

  if (velocity_y.hi > $7f) {
    velocity_y += $80
  }

  x += sbyte(velocity_x.hi)
  y += sbyte(velocity_y.hi)

  cap_fish_location_to_active_tank(x, y, did_change)

  fish_x[i] = x
  fish_y[i] = y

  fish_velocity_x[i] = velocity_x
  fish_velocity_y[i] = velocity_y
}

inline void fish_breed() {
  byte temp
  if (male_small_fish_count < 1 || female_small_fish_count < 1) {
    // Breeding cannot occur
    return
  }

  random_int_const(0, MAX_FISH_COUNT, temp)

  if (temp < (male_small_fish_count + female_small_fish_count) / 2 && rand() < 1) {
    // Breed
    random_int_const(0, 1, temp)
    spawn_fish(tetra, temp == 1)
  }
}

inline void fish_breathe() {
  // TODO: Base on fish size
  byte i

  for i,0,until,active_fish_count {
    if (rand() < $40) {
      increase_ammonia(1)
    }
  }
}

inline void render_fish() {
  byte i
  byte mask
  bool pos_direction
  for i,0,until,active_fish_count {
    pos_direction = sbyte(fish_velocity_x[i].hi) >= 0
    if (pos_direction) {
      mask = 0
    } else {
      mask = %01000000
    }

    if (fish_type[i] == tetra) {
      render_two_tile_fish(i, mask, pos_direction, 1, tetra_tiles.pointer)
    } else if (fish_type[i] == rasbora) {
      render_two_tile_fish(i, mask, pos_direction, 2, rasbora_tiles.pointer)
    } else {
      oam_buffer[oam_index] = fish_y[i]
      oam_buffer[oam_index + 1] = $81
      oam_buffer[oam_index + 2] = mask
      oam_buffer[oam_index + 3] = fish_x[i]

      oam_index += 4
    }
  }
}

macro void render_two_tile_fish(byte i, byte mask, bool pos_direction, byte const palette, pointer.byte const data) {
  oam_buffer[oam_index] = fish_y[i]
  if (pos_direction) {
    oam_buffer[oam_index + 1] = data[0]
  } else {
    oam_buffer[oam_index + 1] = data[1]
  }
  // Palette 1
  oam_buffer[oam_index + 2] = mask | palette
  oam_buffer[oam_index + 3] = fish_x[i] - 8

  oam_index += 4

  oam_buffer[oam_index] = fish_y[i]
  if (pos_direction) {
    oam_buffer[oam_index + 1] = data[1]
  } else {
    oam_buffer[oam_index + 1] = data[0]
  }
  // Palette 1
  oam_buffer[oam_index + 2] = mask | palette
  oam_buffer[oam_index + 3] = fish_x[i]

  oam_index += 4
}

const array(byte) tetra_tiles = [$82, $83]
const array(byte) rasbora_tiles = [$84, $85]