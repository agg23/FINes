import entity/health

import graphics_buffer

enum PlantType {
  rotala
  anubias
  babytears
}

enum PlantSize {
  small
  medium
  large
}

enum PlantPalette {
  palette_red,
  palette_green,
  palette_unset
}

const byte MAX_PLANT_COUNT = 10
const byte PLANT_EDITOR_MAX_PLANT_COUNT = MAX_PLANT_COUNT + 1
const byte MAX_PLANT_COLUMNS = 30

array(bool) plant_active [PLANT_EDITOR_MAX_PLANT_COUNT]
array(PlantType) plant_type [PLANT_EDITOR_MAX_PLANT_COUNT]
array(byte) plant_x [PLANT_EDITOR_MAX_PLANT_COUNT]
array(PlantSize) plant_size [PLANT_EDITOR_MAX_PLANT_COUNT]
array(PlantPalette) plant_current_palettes [MAX_PLANT_COLUMNS >> 1]
array(byte) plant_current_x [MAX_PLANT_COLUMNS]

byte plant_min_x
byte plant_max_x_bound

void init_plants() {
  byte i
  plant_min_x = active_tank.x_low >> 3
  plant_max_x_bound = (active_tank.x_high >> 3) - plant_min_x

  for i,0,until,MAX_PLANT_COLUMNS {
    plant_current_x[i] = $FF
  }

  for i,0,until,15 {
    plant_current_palettes[i] = palette_unset
  }

  add_plant(rotala, 6, large, $FF)

  add_plant(babytears, 8, small, $FF)
  add_plant(babytears, 10, medium, $FF)
  add_plant(babytears, 12, small, $FF)


  // TODO: Adding one more plant crashes the buffer renderer
  // add_plant(babytears, 14, medium)
  add_plant(anubias, 16, medium, $FF)
  // add_plant(babytears, 20, medium)

  // Set defaults for editor
  plant_size[MAX_PLANT_COUNT] = large
}

void add_plant(PlantType type, byte x, PlantSize size, byte max_width) {
  byte i
  byte j
  byte actual_width

  // Last index is reserved for the editor
  for i,0,until,MAX_PLANT_COUNT {
    if (not(plant_active[i])) {
      plant_active[i] = true
      plant_type[i] = type
      plant_x[i] = x
      plant_size[i] = size

      if (plant_expected_width[type] < max_width) {
        actual_width = plant_expected_width[type]
      } else if (max_width < plant_min_width[type]) {
        // Should not happen
        asm {
          kil
        }
      } else {
        actual_width = max_width
      }

      for j,0,until,actual_width {
        plant_current_x[x + j] = i
        plant_current_palettes[(x + j) >> 1] = plant_type_palette[type]
      }
      
      return
    }
  }
}

void render_plant() {
  byte i
  byte temp
  for i,0,until,MAX_PLANT_COUNT {
    if (plant_active[i]) {
      render_plant_i(i, plant_x[i])
    }
  }
}

void render_plant_at_x(byte x) {
  byte i
  for i,0,until,MAX_PLANT_COUNT {
    if (plant_active[i] && plant_x[i] == x) {
      render_plant_i(i, x)
    }
  }
}

void render_plant_i(byte i, byte x) {
  array(byte) data [10]

  if (plant_type[i] == rotala) {
    render_rotala(i, x, data.pointer)
  } else if (plant_type[i] == babytears) {
    render_babytears(i, x, data.pointer)
  } else if (plant_type[i] == anubias) {
    render_anubias(i, x, data.pointer)
  }
}

inline void render_rotala(byte i, byte x, pointer.byte data) {
  byte x_offset
  byte count

  x_offset = x + plant_min_x

  if (plant_size[i] == large) {
    count = 3
  } else if (plant_size[i] == medium) {
    count = 2
  } else {
    count = 1
  }

  byte j
  for j,0,until,count {
    data[j] = $88
  }

  add_buffered_write(ppu_nametable0 + plant_tile_height_from_floor(count) + x_offset, true, data, count)

  data[0] = build_attribute_table(x, rotala)
  // active_tank.y_high / 32 * 8
  // TODO: Properly combine these shifts with a mask
  add_buffered_write(ppu_attrtable0 + ((word(active_tank.y_high) >> 5) << 3) + (x_offset >> 2), false, data, 1)
}

inline void render_babytears(byte i, byte x, pointer.byte data) {
  byte x_offset
  word height_from_floor

  x_offset = x + plant_min_x

  if (plant_size[i] == medium) {
    data[0] = $9E
    data[1] = $9F

    height_from_floor = ((word(active_tank.y_high) >> 3) - 1) * 32

    add_buffered_write(ppu_nametable0 + height_from_floor + x_offset, false, data, 2)

    data[0] = $A8
    data[1] = $A9
    add_buffered_write(ppu_nametable0 + height_from_floor + 32 + x_offset, false, data, 2)
  } else if (plant_size[i] == small) {
    data[0] = $9C
    data[1] = $9D

    height_from_floor = (word(active_tank.y_high) >> 3) * 32

    add_buffered_write(ppu_nametable0 + height_from_floor + x_offset, false, data, 2)
  }

  data[0] = build_attribute_table(x, babytears)
  // data[1] = build_attribute_table(x + 2, babytears)
  // active_tank.y_high / 32 * 8
  // TODO: Properly combine these shifts with a mask
  add_buffered_write(ppu_attrtable0 + ((word(active_tank.y_high) >> 5) << 3) + (x_offset >> 2), false, data, 1)
}

inline void render_anubias(byte i, byte x, pointer.byte data) {
  byte x_offset
  word height_from_floor

  x_offset = x + plant_min_x

  data[0] = $89
  data[1] = $8C
  data[2] = $8F
  data[3] = $9A

  height_from_floor = ((word(active_tank.y_high) >> 3) - 3) * 32

  add_buffered_write(ppu_nametable0 + height_from_floor + x_offset, true, data, 4)

  data[0] = $8A
  data[1] = $8D
  data[2] = $98
  data[3] = $9B
  add_buffered_write(ppu_nametable0 + height_from_floor + x_offset + 1, true, data, 4)

  data[0] = $8B
  data[1] = $8E
  data[2] = $99
  data[3] = $0
  add_buffered_write(ppu_nametable0 + height_from_floor + x_offset + 2, true, data, 4)

  data[0] = build_attribute_table(x, anubias)
  data[1] = build_attribute_table(x + 2, anubias)
  // active_tank.y_high / 32 * 8
  // TODO: Properly combine these shifts with a mask
  add_buffered_write(ppu_attrtable0 + ((word(active_tank.y_high) >> 5) << 3) + (x_offset >> 2), false, data, 2)
}

byte build_attribute_table(byte x, PlantType type) {
  PlantPalette temp_palette
  byte prev_palette_number
  byte next_palette_number
  byte output

  if ((x + plant_min_x) & 2 != 0) {
    // Odd position, need to consider previous palette
    if (x < 3) {
      // Prev is wall
      prev_palette_number = 0
    } else {
      temp_palette = plant_current_palettes[(x >> 1) - 1]

      prev_palette_number = palette_number_for_palette(temp_palette)
    }

    next_palette_number = palette_number_for_palette(plant_type_palette[type])
  } else {
    // Even position, need to consider next palette
    if (x > plant_max_x_bound - 3) {
      // Next is wall
      next_palette_number = 0
    } else {
      temp_palette = plant_current_palettes[(x >> 1) + 1]

      next_palette_number = palette_number_for_palette(temp_palette)
    }

    prev_palette_number = palette_number_for_palette(plant_type_palette[type])
  }

  output = next_palette_number
  output = (output << 2) | prev_palette_number
  output = (output << 2) | next_palette_number
  output = (output << 2) | prev_palette_number

  return output
}

inline byte palette_number_for_palette(PlantPalette type) {
  if (type == palette_green) {
    return 1
  } else if (type == palette_red) {
    return 2
  }

  return 0
}

void plant_tick() {
  byte i

  for i,0,until,MAX_PLANT_COUNT {
    if (not(plant_active[i])) {
      continue
    }

    if (rand() < $60) {
      decrease_ammonia(1)
    }
  }
}

inline word plant_tile_height_from_floor(byte height) {
  return ((word(active_tank.y_high) >> 3) - height + 1) * 32
}

// rotala, anubias, babytears
const array(byte) plant_expected_width[PlantType] = [1, 3, 2]
const array(byte) plant_min_width[PlantType] = [1, 3, 1]
const array(PlantPalette) plant_type_palette[PlantType] = [palette_red, palette_green, palette_green]